# 1. Resumo executivo
- O endpoint `/ops/quality/report` monta o `top2_gap_p50` consultando o Prometheus via `histogram_quantile` sobre `sirios_planner_top2_gap_histogram_bucket` em várias janelas.
- Quando todas as consultas retornam `NaN` (típico quando o histograma não recebeu amostras recentes), `_first_nonzero_expr` devolve esse `NaN` porque nenhuma janela entregou valor `> 0`.
- O valor `NaN` passa para `_sanitize`, que o converte explicitamente em `0.0` antes de arredondar, produzindo `0.000` no payload.
- Assim, o `0.000` não representa um gap real zero, mas sim ausência de dados válidos na métrica origem.
- O mesmo fluxo também zera se as consultas retornarem literalmente `0` (sem gap positivo) ou se forem derrubadas para `0` por fallback `_to_float` em respostas inesperadas.

# 2. Rastro de cálculo end-to-end
```
app/api/ops/quality.py:L424-L553
424: @router.get("/ops/quality/report")
425: def quality_report():
...
485:     # Métricas brutas
486:     top1_hit = prom_query_instant('sum(sirios_planner_top1_match_total{result="hit"})')
...
496:     # Gap P50 — tentar múltiplas janelas e fallback para increase()
497:     windows_csv = os.getenv("QUALITY_GAP_WINDOWS", "10m,1h,6h,24h")
498:     windows = [w.strip() for w in windows_csv.split(",") if w.strip()]
499:     exprs = []
500:     for w in windows:
501:         exprs.append(
502:             f"histogram_quantile(0.50, sum(rate(sirios_planner_top2_gap_histogram_bucket[{w}])) by (le))"
503:         )
504:     # fallback com increase (útil quando o rate é ~0 num curto período)
505:     for w in windows:
506:         exprs.append(
507:             f"histogram_quantile(0.50, sum(increase(sirios_planner_top2_gap_histogram_bucket[{w}])) by (le))"
508:         )
509:
510:     gap_p50_v = _first_nonzero_expr(exprs)
...
533:     metrics = {
534:         "top1_accuracy": _sanitize(top1_acc),
535:         "routed_rate": _sanitize(routed_rt),
536:         "top2_gap_p50": _sanitize(gap_p50_v),
```
- Handler gera lista de expressões PromQL, chama `_first_nonzero_expr` e sanitiza antes de responder.
```
app/api/ops/quality.py:L29-L56
29: def _to_float(x) -> float:
30:     if isinstance(x, (int, float)):
31:         return float(x)
...
46: def _ratio(num, den) -> float:
47:     n, d = _to_float(num), _to_float(den)
48:     return (n / d) if d > 0 else 0.0
51: def _sanitize(v: float) -> float:
52:     if not isinstance(v, (int, float)):
53:         return 0.0
54:     if math.isnan(v) or math.isinf(v):
55:         return 0.0
56:     return round(float(v), 6)
```
- `_sanitize` converte `NaN/inf` em `0.0`, arredonda para 6 casas.
```
app/api/ops/quality.py:L59-L70
59: def _first_nonzero_expr(exprs: List[str]) -> float:
60:     """Executa, em ordem, e retorna o primeiro valor > 0 (ou o último valor obtido)."""
61:     last = 0.0
62:     for e in exprs:
63:         try:
64:             val = _to_float(prom_query_instant(e))
65:             last = val
66:             if val > 0.0:
67:                 return val
68:         except Exception:
69:             continue
70:     return last
```
- Fallback guarda o último valor consultado (pode ser `NaN` ou `0.0`).
```
app/observability/runtime.py:L68-L82
68: def prom_query_instant(expr: str):
69:     base = os.getenv("PROMETHEUS_URL", "http://prometheus:9090").rstrip("/")
70:     url = f"{base}/api/v1/query?query={urllib.parse.quote_plus(expr)}"
...
77:     if len(result) == 1 and "value" in result[0] and len(result[0]["value"]) == 2:
78:         try:
79:             return float(result[0]["value"][1])
80:         except Exception:
81:             return data
82:     return data
```
- Consulta instantânea devolve float (`NaN` possível quando histogram_quantile não tem amostras).
```
app/api/ask.py:L75-L81
75:     if explain:
76:         top2_gap = float(
77:             ((plan.get("explain") or {}).get("scoring") or {}).get("intent_top2_gap")
78:             or 0.0
79:         )
80:         histogram("sirios_planner_top2_gap_histogram", top2_gap)
```
```
app/orchestrator/routing.py:L194-L233
194:         scoring_block = exp.get("scoring") or {}
...
197:         top2_gap = float(
198:             thr_info.get(
199:                 "gap",
200:                 scoring_block.get(
201:                     "intent_top2_gap_final",
202:                     scoring_block.get("intent_top2_gap_base", 0.0),
203:                 ),
204:             )
205:             or 0.0
206:         )
...
234:         gate = {
235:             "blocked": False,
236:             "reason": None,
237:             "min_score": min_score,
238:             "min_gap": min_gap,
239:             "top2_gap": top2_gap,
```
- Planner calcula o gap (base e final), roteador lê `intent_top2_gap_final/base`; push/ask registram histograma.
```
app/planner/planner.py:L388-L417
388:         ordered_base = sorted(intent_scores.items(), key=lambda kv: kv[1], reverse=True)
389:         gap_base = 0.0
390:         if len(ordered_base) >= 2:
391:             gap_base = float((ordered_base[0][1] or 0.0) - (ordered_base[1][1] or 0.0))
...
396:         ordered_final = sorted(fused_scores.items(), key=lambda kv: kv[1], reverse=True)
397:         gap_final = 0.0
398:         if len(ordered_final) >= 2:
399:             gap_final = float(
400:                 (ordered_final[0][1] or 0.0) - (ordered_final[1][1] or 0.0)
401:             )
```
- Origem do gap individual enviado à telemetria.
```
app/observability/metrics.py:L35-L70
35:     "sirios_planner_duration_seconds": {
...
46:     "sirios_planner_top2_gap_histogram": {"type": "histogram", "labels": set()},
```
- Catálogo de métricas define histograma utilizado pelo Prometheus.
```
data/ops/observability.yaml:L100-L113
100:       planner_intent_score:
...
110:       planner_top2_gap_histogram:
111:         enabled: true
112:         buckets: [0.0, 0.5, 1, 2, 3, 5]
```
- Configuração de buckets do histograma.

# 3. Locais de possível manipulação
- `_sanitize` (`app/api/ops/quality.py:L51-L56`): converte `NaN/Inf` para `0.0`, arredonda com `round(..., 6)`.
- `_first_nonzero_expr` (`app/api/ops/quality.py:L59-L70`): ignora qualquer valor `<= 0` e retorna o último observado, permitindo que `NaN` (último) chegue adiante.
- `_to_float` (`app/api/ops/quality.py:L29-L43`): retorna `0.0` em caso de payload Prometheus inesperado, funcionando como default.
- Formatação `.3f` aparece apenas em mensagens de violação (`L520-L529`), mas não altera o JSON — demonstra arredondamento textual para 3 casas.

# 4. Provas
- Quando `histogram_quantile` não tem amostras, Prometheus responde `NaN`. `_first_nonzero_expr` salva `last = NaN` (L61-L66) e retorna `NaN` porque nenhum valor `> 0.0` surgiu. `_sanitize` detecta `math.isnan(v)` e devolve `0.0` (L51-L55), produzindo o `top2_gap_p50 = 0.000` exibido.
- Se as consultas retornarem `0.0` (gap inexistente), `_first_nonzero_expr` nunca encontra `> 0.0` e retorna `last` (0.0), resultando em `0.000` após `_sanitize`.
- Quaisquer exceções de rede/timeout em `prom_query_instant` são engolidas pelo `except` de `_first_nonzero_expr`, que ignora o erro e mantém `last` (default inicial `0.0`), também gerando `0.000`.

# 5. Hipóteses testáveis (não executar; apenas registrar)
- Inserir um log/print temporário antes do retorno de `_first_nonzero_expr` para registrar cada `val` coletado e verificar se estão `NaN`.
- Rodar manualmente `curl "$PROMETHEUS_URL/api/v1/query?query=$(urlencode(expr))"` para cada expressão gerada e inspecionar o campo `value[1]`.
- Comparar `gap_p50_v` antes e depois de `_sanitize` via log para confirmar a queda de `NaN` → `0.0`.
- Consultar `increase(sirios_planner_top2_gap_histogram_count[24h])` para verificar se há eventos gravados recentemente.

# 6. Fontes do valor
- Origem: Prometheus (consulta instantânea). Expressões geradas no handler (`histogram_quantile(0.50, sum(rate(...[{window}])) by (le))` e fallback `increase`).
- Métrica base: `sirios_planner_top2_gap_histogram_bucket` / `_count` / `_sum`, sem labels.
- Janelas: configuráveis via `QUALITY_GAP_WINDOWS` (default `10m,1h,6h,24h`). Cada janela tenta `rate` e, em seguida, `increase`.
- Percentil: calculado via `histogram_quantile(0.50, ...)` no Prometheus; nenhuma pós-transformação adicional além de `_sanitize` no backend.
- Geração de amostras: `app/api/ask.py:L75-L81` (requisições `ask` com `explain=True`) e `app/api/ops/quality.py:L107-L140` (rota `/ops/quality/push`) enviam gaps individuais para o histograma. O valor individual vem do planner (`app/planner/planner.py:L388-L401`), passado pelo roteador (`app/orchestrator/routing.py:L194-L239`).

# 7. Riscos de falsos zeros
- Lista vazia / ausência de eventos: `histogram_quantile` retorna `NaN`, sanitizado para `0.0`.
- Filtro total por `val > 0`: `_first_nonzero_expr` descarta valores `== 0`, podendo ignorar gaps válidos exatamente nulos e retornar fallback.
- Conversão default: `_to_float` transforma respostas inesperadas em `0.0`.
- Timeout/erro na consulta: exceção suprimida resulta em `last` (`0.0`).
- Buckets configurados começam em `0.0`; se só o bucket zero cresce, quantile pode retornar `0`, mantendo `0.0`.

# 8. Check-list de verificação manual
1. Identificar as janelas atuais: `echo $QUALITY_GAP_WINDOWS` (default `10m,1h,6h,24h`).
2. Para cada expressão de `rate`, montar a URL `curl "$PROMETHEUS_URL/api/v1/query?query=$(python - <<'PY'
import urllib.parse
print(urllib.parse.quote_plus("histogram_quantile(0.50, sum(rate(sirios_planner_top2_gap_histogram_bucket[10m])) by (le))"))
PY
)"` e inspecionar `data.result[0].value[1]`.
3. Repetir com as expressões `increase` correspondentes.
4. Registrar se algum valor é `NaN`, `0` ou ausente.
5. Consultar `curl "$PROMETHEUS_URL/api/v1/query?query=sum(increase(sirios_planner_top2_gap_histogram_count[24h]))"` para validar volume de eventos.
6. (Opcional) Adicionar log temporário antes de `_sanitize(gap_p50_v)` e verificar no log do serviço.

# 9. Anexos
- `app/api/ops/quality.py`
- `app/observability/runtime.py`
- `app/api/ask.py`
- `app/orchestrator/routing.py`
- `app/planner/planner.py`
- `app/observability/metrics.py`
- `data/ops/observability.yaml`
